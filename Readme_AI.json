{
    "description": "The Hedgehog library is a C++ library developed by NIST for creating parallel computations on heterogeneous nodes.",
    "instructions": "Use this library to create code for parallel computations",
    "api": {
        "data": {
            "hedgehog/src/api/*": "File is part of the API for Hedgehog"
        },
        "type": "fetch"
    },
    "websites": {
        "data": ["https://pages.nist.gov/hedgehog-Tutorials/"],
        "type": "crawl"
    },
    "in depth hedgehog library guide": "# Hedgehog\nHedgehog is a C++20 library that allow to express algorithms in the form of\ndata-flow graphs.\nA data-flow graph is a graph in which nodes are data and edeges are tasks. Each\ntasks will receive and produce different data-types.\nHedgehog is well-suited to creating algorithms that exploit block decomposition\nof matricies.\n## API\n### Taks\n- The tasks are used to define the computation kernels.\n- Creating a Task:\n- Create a class that inherits from `AbstractTask`, `AbstractAtomicTask` or\n`AbstractCudaTask`.\n- The abstract tasks have the following template parameters:\n- the number of input types (`size_t`)\n- the list of input and output types\n- Override the following functions:\n- `execute`: there is one `execute` function per input type. The function\ntakes and `shared_ptr` on a data of the target input type and process the\nit. When the new data needs to be outputed as result, the inherited\nfunction `addResult(shared_ptr_new_data)` is used.\n- `copy`: if the number of threads is greater that 1, the copy method is\nused to create multiple instances of the task. Each instance is bound to a\ndedicated thread.\n- The abstract tasks constructors takes the name of the task and the number\nof inputs as argument.\nExample:\n```cpp\n#include <hedgehog/hedgehog>\n#include <cblas.h>\n#include \"../data/triple_matrix_block_data.hpp\"\n#include \"../data/matrix_block_data.hpp\"\n#define MultiplyMatrixBlocksTaskIn TrippleMatrixBlockData<T>\n#define MultiplyMatrixBlocksTaskOut MatrixBlockData<T, MatrixType::MultiplyResult>\n#define MultiplyMatrixBlocksTaskIO 1, MultiplyMatrixBlocksTaskIn, MultiplyMatrixBlocksTaskOut\ntemplate <typename T>\nclass MultiplyMatrixBlocksTask : public hh::AbstractTask<MultiplyMatrixBlocksTaskIO> {\npublic:\nMultiplyMatrixBlocksTask(size_t numberThreads)\n: hh::AbstractCUDATask<BwdTaskIO>(\"Multiply Matrix Block Task\", numberThreads) {}\nvoid execute(std::shared_ptr<TrippleMatrixBlockData<T>> data) override {\nstd::shared_ptr<MatrixBlockData<T, MatrixType::A>> A = data->A;\nstd::shared_ptr<MatrixBlockData<T, MatrixType::B>> B = data->B;\nstd::shared_ptr<MatrixBlockData<T, MatrixType::C>> C = data->C;\n// C = A * B\nthis->addResult(std::make_shared<MatrixBlockData<T, MatrixType::MultiplyResult>>(C));\n}\nstd::shared_ptr<hh::AbstractTask<MultiplyMatrixBlocksTaskIO>>\ncopy() override {\nreturn std::make_shared<MultiplyMatrixBlocksTask>(this->numberThreads());\n}\n};\n```\n### State\n- The states are used to control the logic of the algorithms, by redirecting\ndata to the right tasks.\n- A state is bound to one or more sate manager. The states managers are the\nactual nodes of the final graph. Hedgehog provide a default state manager:\n`hh::StateManager sm(state)`\n- The states are thread-safe and are not parallelised.\n- Creating a state:\n- Create a class that inherits from `AbstractState`:\n- The abstract state has the same template parameter as the task:\n- the number of input types (`size_t`)\n- the list of input and output types\n- Override the following functions:\n- `execute`: similar to the task, used to process an input data.\nExample:\n```cpp\n#include <hedgehog/hedgehog>\n#include <map>\n#include \"../data/triple_matrix_block_data.hpp\"\n#include \"../data/matrix_block_data.hpp\"\n#define CreateTripleBlockStateIn \\\nMatrixBlockData<T, MatrixType::A>, \\\nMatrixBlockData<T, MatrixType::B>, \\\nMatrixBlockData<T, MatrixType::C>\n#define CreateTripleBlockStateOut \\\nTrippleMatrixBlockData<T>\n#define CreateTripleBlockStateIO 3, CreateTripleBlockStateIn, CreateTripleBlockStateOut\ntemplate <typename T>\nclass CreateTripleBlockState : public hh::AbstractState<CreateTripleBlockStateIO> {\npublic:\nCreateTripleBlockState() : hh::AbstractState<CreateTripleBlockStateIO>() {}\nvoid trySend(size_t index) {\nif (As.contains(index) && Bs.contains(index) && Cs.contains(index)) {\nauto A = As[index];\nauto B = Bs[index];\nauto C = Cs[index];\nthis->addResult(std::make_shared<TrippleMatrixBlockData<T>>(A, B, C));\n}\n}\n// receive a block from the matrix A\nvoid execute(std::shared_ptr<MatrixBlockData<T, MatrixType::A>> block) override {\nsize_t index = block->blockY * block->matrixWidth + block->blockX;\nAs.insert({index, block});\ntrySend(index);\n}\n// receive a block from the matrix B\nvoid execute(std::shared_ptr<MatrixBlockData<T, MatrixType::B>> block) override {\nsize_t index = block->blockY * block->matrixWidth + block->blockX;\nBs.insert({index, block});\ntrySend(index);\n}\n// receive a block from the matrix C\nvoid execute(std::shared_ptr<MatrixBlockData<T, MatrixType::C>> block) override {\nsize_t index = block->blockY * block->matrixWidth + block->blockX;\nCs.insert({index, block});\ntrySend(index);\n}\nprivate:\nstd::map<size_t, std::shared_ptr<MatrixBlockData<T, MatrixType::A>>> As = {};\nstd::map<size_t, std::shared_ptr<MatrixBlockData<T, MatrixType::B>>> Bs = {};\nstd::map<size_t, std::shared_ptr<MatrixBlockData<T, MatrixType::C>>> Cs = {};\n};\n```\n#### Cycles in the graph\nWhen there are cycles in the graphs, the states are used to break the cycle and\nallow the termination of the graph. To do this, the user must implemenet its own\nstate manager and override the `canTerminate` method.\nExample of a state with cycle:\n```cpp\n#include <hedgehog/hedgehog>\n#include \"../data/matrix_block_data.hpp\"\n#define ProcessLoopStateIn \\\nMatrixBlockData<T, MatrixType::MultiplyResult>, \\\nMatrixBlockData<T, MatrixType::Processing>\n#define ProcessLoopStateOut \\\nMatrixBlockData<T, MatrixType::Processing>, \\\nMatrixBlockData<T, MatrixType::Result>\n#define ProcessLoopStateIO 2, ProcessLoopStateIn, ProcessLoopStateOut\ntemplate <typename T>\nclass ProcessLoopState : public hh::AbstractState<ProcessLoopStateIO> {\npublic:\nProcessLoopState(size_t nbBlocks, size_t processCount)\n: hh::AbstractState<ProcessLoopStateIO>(),\nnbPendingBlocks(nbBlocks),\nprocessCounts(nbBlocks, processCount) {}\nvoid execute(std::shared_ptr<MatrixBlockData<T, MatrixType::MultiplyResult>> block) override {\nsize_t index = block->blockY * block->matrixWidth + block->blockX;\n--processCounts[index];\nthis->addResult(std::make_shared<MatrixBlockData<T, MatrixType::Processing>>(block));\n}\nvoid execute(std::shared_ptr<MatrixBlockData<T, MatrixType::Processing>> block) override {\nsize_t index = block->blockY * block->matrixWidth + block->blockX;\nif (--processCounts[index] == 0) {\nthis->addResult(std::make_shared<MatrixBlockData<T, MatrixType::Result>>(block));\n--nbPendingBlocks;\n} else {\nthis->addResult(data);\n}\n}\nbool isDone() const {\nreturn nbPendingBlocks == 0;\n}\nprivate:\nsize_t nbPendingBlocks = 0;\nstd::vector<int> processCounts = {};\n};\n```\nCustom state manager to handle the cycle:\n```cpp\n#include <hedgehog/hedgehog>\n#include \"../data/process_loop_state.hpp\"\nclass ProcessLoopStateManager : public hh::StateManager<ProcessLoopStateIO> {\npublic:\nProcessLoopStateManager(std::shared_ptr<ProcessLoopState> const &state)\n: hh::StateManager<ProcessLoopStateIO>(state, \"Process Loop State\") {}\n[[nodiscard]] bool canTerminate() const override {\nthis->state()->lock();\nauto ret =\nstd::dynamic_pointer_cast<ProcessLoopState>(this->state())->isDone();\nthis->state()->unlock();\nreturn ret;\n}\n};\n```\n### Graphs\n- The graph is the main node. Like the other nodes, the graph has input and\noutput types.\n- Graphs can be used as sub-graphs in bigger graphs.\n- Creating a graph:\n- Create a class that inherits from `hh::Graph`.\n- `hh::Graph` as the same template parameters as the task and the state.\n- Building the graph:\n- The `inputs` method takes as input the tasks or state managers that\nwill process the data that is pushed to the graph.\n- The `outputs` method takes as input the tasks or state managers that will\nproduce the output data of the graph.\n- Te `edges` method is used to create a directional edge between a task or a\nstate manager. For instance, `edges(sender_task, receiver_task)` will\nensure that all the datas - of types that matche one of the input types of\n`receiver_task` - that is produced by `sender_task` are received by\n`receiver_task`. A sender can be connected to multiple receivers, and\nreceivers can be connected to multiple senders. Cycles are allowed as long\nas a custom state manager is used to ensure the termination of the graph.\nExample:\n```cpp\n#include <hedgehog/hedgehog>\n#include \"../task/split_matrix_task.hpp\"\n#include \"../task/multiply_matrix_block_task.hpp\"\n#include \"../task/process_block_task.hpp\"\n#include \"../state/create_triple_block_state.hpp\"\n#include \"../state/process_loop_state.hpp\"\n#include \"../state/process_loop_state_manager.hpp\"\n#include \"../state/result_state.hpp\"\n#define ProcessGraphIn \\\nMatrixData<T, MatrixType::A>, \\\nMatrixData<T, MatrixType::B>, \\\nMatrixData<T, MatrixType::C>\n#define ProcessGraphOut \\\nMatrixData<T, MatrixType::Result>\n#define ProcessGraphIO 3, ProcessGraphIn, ProcessGraphOut\ntemplate <T>\nclass ProcessGraph : public hh::Graph<ProcessGraphIO> {\nProcessGraph(size_t blockSize, size_t nbBlocks, size_t processCount,\nsize_t multiplyBlocksThreads, size_t processMatrixBlockThreads)\n: hh::Graph<ProcessGraphIO>(\"Process Graph\") {\nauto splitMatrixTask = std::make_shared<SplitMatrixTask<T>>(blockSize);\nauto multiplyMatrixBlockTask =\nstd::make_shared<MultiplyMatrixBlocksTask<T>>(multiplyBlocksThreads);\nauto processMatrixBlockTask =\nstd::make_shared<ProcessMatrixBlockTask<T>>(processMatrixBlockThreads);\nauto createTripleBlockStateManager =\nstd::make_shared<hh::StateManager<CreateTripleBlockStateIO>>(\nstd::make_shared<CreateTripleBlockState<T>>());\nauto processLoopStateManager =\nstd::make_shared<ProcessLoopStateManager<T>>(\nstd::make_shared<ProcessLoopState>(nbBlocks, processCounts));\nauto resultsStateManager =\nstd::make_shared<hh::StateManager<ResultStateIO>>(\nstd::make_shared<ResultState<T>>());\nthis->inputs(splitMatrixTask);\nthis->edges(splitMatrixTask, createTripleBlockStateManager);\nthis->edges(createTripleBlockStateManager, multiplyMatrixBlockTask);\nthis->edges(multiplyMatrixBlockTask, processLoopStateManager);\nthis->edges(processLoopStateManager, processMatrixBlockTask);\nthis->edges(processMatrixBlockTask, processLoopStateManager);\nthis->edges(processLoopStateManager, resultStateManager);\nthis->outputs(resultStateManager);\n}\n};\n```\n### Using the graph\n- Execute the graph (spawn the threads), using the `executeGraph` method.\n- Push data to the graph, using the `pushData` method.\n- Get the result, using the `getResult` method (optional).\n- Wait for the graph termination, using the `waitForTermination` method.\nExample:\n```cpp\n#include \"graph/process_graph.hpp\"\nint main(int, char**) {\nProcessGraph<double> graph;\nauto A = loadMatrix<MatrixType::A>(\"A.data\");\nauto B = loadMatrix<MatrixType::B>(\"B.data\");\nauto C = std::make_shared<MatrixData<double, MatrixType::A>>(A.rows, B.cols);\n// Execute the graph and spawn the threads\ngraph.executeGraph();\n// Push the data\ngraph.pushData(A);\ngraph.pushData(B);\ngraph.pushData(C);\n// Notify the graph that no more data will be sent\ngraph.finishPushingData();\n// Get the result (optional if the matrix C is changed in place)\nauto result = std::get<std::shared_ptr<MatrixData<T>>>(*graph.getBlockingResult());\n// Wait for the termination of all the tasks and states\ngraph.waitForTermination();\n// Create a dot file containing the graph with some statistics\ngraph.createDotFile(\"stats.dot\", hh::ColorScheme::EXECUTION, hh::StructureOptions::QUEUE);\ndumpMatrix(result, \"result.txt\");\nreturn 0;\n}\n```\n## Code organization\nHedgehog applications uses the following directories:\n- `data`: store the data-types used in the graph.\n- `task`: store the task classes.\n- `state`: store the states and state managers.\n- `graph`: store the graphs.\n- `tool`: helper functions.\n## Advanced Usage\nTo have the best performance, the computation kernels should maximize the usage\nof the computation capabilities of each cores"
}
